*tabpage.txt*   For Vim version 7.0aa.  Last change: 2006 Feb 24


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Editing with windows in multiple tab pages.		*tab-page* *tabpage*

The commands which have been added to use multiple tab pages are explained
here.  Additionally, there are explanations for commands that work differently
when used in combination with more than one tab page.

1. Introduction			|tab-page-intro|
2. Commands			|tab-page-commands|
3. Other items			|tab-page-other|
4. Setting 'tabline'		|setting-tabline|

{Vi does not have any of these commands}
{not able to use multiple tab pages when the |+windows| feature was disabled
at compile time}

==============================================================================
1. Introduction						*tab-page-intro*

A tab page holds one or more windows.  You can easily switch between tab
pages, so that you have several collections of windows to work on different
things.

Usually you will see a list of labels at the top of the Vim window, one for
each tab page.  With the mouse you can click on the label to jump to that tab
page.  There are other ways to move between tab pages, see below.

Most commands work only in the current tab page.  That includes the |CTRL-W|
commands, |:windo|, |:all| and |:ball|.  The commands that are aware of
other tab pages than the current one are mentioned below.

Tabs are also a nice way to edit a buffer temporarily without changing the
current window layout.  Open a new tab page, do whatever you want to do and
close the tab page.

==============================================================================
2. Commands						*tab-page-commands*

OPENING A NEW TAB PAGE:

When starting Vim "vim -p filename ..." opens each file argument in a separate
tab page (up to 10). |-p|

A double click with the mouse in the tab pages line opens a new, empty tab
page.  It is placed left of the position of the click.  The first click may
select another tab page first, causing an extra screen update.

:tabe[dit]				*:tabe* *:tabedit* *:tabnew*
:tabnew		Open a new tab page with an empty window, after the current
		tab page.

:tabe[dit] [++opt] [+cmd] {file}
:tabnew [++opt] [+cmd] {file}
		Open a new tab page and edit {file}, like with |:edit|.

:tabf[ind] [++opt] [+cmd] {file}			*:tabf* *:tabfind*
		Open a new tab page and edit {file} in 'path', like with
		|:find|.
		{not available when the |+file_in_path| feature was disabled
		at compile time}

:[count]tab {cmd}					*:tab*
		Execute {cmd} and when it opens a new window open a new tab
		page instead.  Doesn't work for |:diffsplit| or |:diffpatch|.
		When [count] is omitted the tab page appears after the current
		one.  When [count] is specified the new tab page comes after
		tab page [count].  Use ":0tab cmd" to get the new tab page as
		the first one.  Examples: >
			:tab split	" opens current buffer in new tab page
			:tab help gt	" opens tab page with help for "gt"


CLOSING A TAB PAGE:

Closing the last window of a tab page closes the tab page too, unless there is
only one tab page.

Using the mouse: If the tab page line is displayed you can click in the "X" at
the top right to close the current tab page.  A custom |'tabline'| may show
something else.

							*:tabc* *:tabclose*
:tabc[lose][!]	Close current tab page.
		This command fails when:
		- There is only one tab page on the screen.		*E784*
		- When 'hidden' is not set, [!] is not used, a buffer has
		  changes, and there is no other window on this buffer.
		Changes to the buffer are not written and won't get lost, so
		this is a "safe" command.

:tabc[lose][!] {count}
		Close tab page {count}.  Fails in the same way as ':tabclose"
		above.

							*:tabo* *:tabonly*
:tabo[nly][!]	Close all other tab pages.
		When the 'hidden' option is set, all buffers in closed windows
		become hidden.
		When 'hidden' is not set, and the 'autowrite' option is set,
		modified buffers are written.  Otherwise, windows that have
		buffers that are modified are not removed, unless the [!] is
		given, then they become hidden.  But modified buffers are
		never abandoned, so changes cannot get lost.


SWITCHING TO ANOTHER TAB PAGE:

Using the mouse: If the tab page line is displayed you can click in a tab page
label to switch to that tab page.  Click where there is no label to go to the
next tab page.  |'tabline'|

:tabn[ext]					*:tabn* *:tabnext* *gt*
gt		Go to the next tab page.  Wraps around from the last to the
		first one.

:tabn[ext] {count}
{count}gt	Go to tab page {count}.  The first tab page has number one.


:tabp[revious]				*:tabp* *:tabprevious* *gT*
:tabN[ext]				*:tabN* *:tabNext*
gT		Go to the previous tab page.  Wraps around from the first one
		to the last one.

:tabp[revious] {count}
:tabN[ext] {count}
{count}gT	Go {count} tab pages back.  Wraps around from the first one
		to the last one.

:tabr[ewind]			*:tabfir* *:tabfirst* *:tabr* *:tabrewind*
:tabl[ast]	Go to the first tab page.

							*:tabl* *:tablast*
:tabl[ast]	Go to the last tab page.


Other commands:
							*:tabs*
:tabs		List the tab pages and the windows they contain.
		Shows a ">" for the current window.
		Shows a "+" for modified buffers.


REORDERING TAB PAGES:

							*:tabm* *:tabmove*
:tabmove N	Move the current tab page to after tab page N.  Use zero to
		make the current tab page the first one.  Without N the tab
		page is made the last one.


LOOPING OVER TAB PAGES:

							*:tabd* *:tabdo*
:tabd[o] {cmd}	Execute {cmd} in each tab page.
		It works like doing this: >
			:tabfirst
			:{cmd}
			:tabnext
			:{cmd}
			etc.
<		This only operates in the current window of each tab page.
		When an error is detected on one tab page, further tab pages
		will not be visited.
		The last tab page (or where an error occurred) becomes the
		current tab page.
		{cmd} can contain '|' to concatenate several commands.
		{cmd} must not open or close tab pages or reorder them.
		{not in Vi} {not available when compiled without the
		|+listcmds| feature}
		Also see |:windo|, |:argdo| and |:bufdo|.

==============================================================================
3. Other items						*tab-page-other*

Diff mode works per tab page.  You can see the diffs between several files
within one tab page.  Other tab pages can show differences between other
files.

The TabLeave and TabEnter autocommand events can be used to do something when
switching from one tab page to another.  The exact order depends on what you
are doing.  When creating a new tab page this works as if you create a new
window on the same buffer and then edit another buffer.  Thus ":tabnew"
triggers:
	WinLeave		leave current window
	TabLeave		leave current tab page
	TabEnter		enter new tab page
	WinEnter		enter window in new tab page
	BufLeave		leave current buffer
	BufEnter		enter new empty buffer

When switching to another tab page the order is:
	BufLeave
	WinLeave
	TabLeave
	TabEnter
	WinEnter
	BufEnter

==============================================================================
4. Setting 'tabline'					*setting-tabline*

You can use the 'showtabline' option to specify when you want the line with
tab page labels to appear: never, when there is more than one tab page or
always.

The highlighting of the tab pages line is set with the groups TabLine
TabLineSel and TabLineFill.  |hl-TabLine| |hl-TabLineSel| |hl-TabLineFill|

The 'tabline' option allows you to define your preferred way to tab pages
labels.  This isn't easy, thus an example will be given here.

For basics see the 'statusline' option.  The same items can be used in the
'tabline' option.  Additionally, the |tabpagebuflist()|, |tabpagenr()| and
|tabpagewinnr()| functions are useful.

Since the number of tab labels will vary, you need to use an expresion for the
whole option.  Something like: >
	:set tabline=%!MyTabLine()

Then define the MyTabLine() function to list all the tab pages labels.  A
convenient method is to split it in two parts:  First go over all the tab
pages and define labels for them.  Then get the label for each tab page. >

	function MyTabLine()
	  let s = ''
	  for i in range(tabpagenr('$'))
	    " select the highlighting
	    if i + 1 == tabpagenr()
	      let s .= '%#TabLineSel#'
	    else
	      let s .= '%#TabLine#'
	    endif

	    " set the tab page number (for mouse clicks)
	    let s .= '%' . (i + 1) . 'T'

	    " the label is made by MyTabLabel()
	    let s .= ' %{MyTabLabel(' . (i + 1) . ')} '
	  endfor

	  " after the last tab fill with TabLineFill and reset tab page nr
	  let s .= '%#TabLineFill#%T'

	  " right-align the label to close the current tab page
	  if tabpagenr('$') > 1
	    let s .= '%=%#TabLine#%999Xclose'
	  endif

	  return s
	endfunction

Now the MyTabLabel() function is called for each tab page to get its label. >

	function MyTabLabel(n)
	  let buflist = tabpagebuflist(a:n)
	  let winnr = tabpagewinnr(a:n)
	  return bufname(buflist[winnr - 1])
	endfunction

This is just a simplistic example that results in a tab pages line that
resembles the default, but without adding a + for a modified buffer or
trunctating the names.  You will want to reduce the width of labels in a
clever way when there is not enough room.  Check the 'columns' option for the
space available.

 vim:tw=78:ts=8:ft=help:norl:
