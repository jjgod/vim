Tests for List and Dictionary types.     vim: set ft=vim :

STARTTEST
:so small.vim
:fun Test()
:" Creating List directly with different types
:let l = [1, 'as''d', [1, 2, function("strlen")], {'a': 1},]
:$put =string(l)
:$put =string(l[-1])
:$put =string(l[-4])
:try
:  $put =string(l[-5])
:catch
:  $put =v:exception[:14]
:endtry
:"
:" List identity
:let ll = l
:let lx = copy(l)
:try
:  $put =(l == ll) . (l isnot ll) . (l is ll) . (l == lx) . (l is lx) . (l isnot lx)
:catch
:  $put =v:exception
:endtry
:"
:" Creating Dictionary directly with different types
:let d = {001: 'asd', 'b': [1, 2, function('strlen')], -1: {'a': 1},}
:$put =string(d) . d.1
:$put =string(sort(keys(d)))
:$put =string(values(d))
:for [key, val] in items(d)
:  $put =key . ':' . string(val)
:  unlet key val
:endfor
:call extend(d, {3:33, 1:99})
:call extend(d, {'b':'bbb', 'c':'ccc'}, "keep")
:try
:  call extend(d, {3:333,4:444}, "error")
:catch
:  $put =v:exception[:15] . v:exception[-1:-1]
:endtry
:$put =string(d)
:call filter(d, 'v:key =~ ''[ac391]''')
:$put =string(d)
:"
:" Dictionary identity
:let dd = d
:let dx = copy(d)
:try
:  $put =(d == dd) . (d isnot dd) . (d is dd) . (d == dx) . (d is dx) . (d isnot dx)
:catch
:  $put =v:exception
:endtry
:"
:" Changing var type should fail
:try
:  let d = []
:catch
:  $put =v:exception[:14] . v:exception[-1:-1]
:endtry
:try
:  let l = {}
:catch
:  $put =v:exception[:14] . v:exception[-1:-1]
:endtry
:"
:" removing items with :unlet
:unlet l[2]
:$put =string(l)
:let l = range(8)
:unlet l[:3]
:unlet l[1:]
:$put =string(l)
:"
:unlet d.c
:unlet d[-1]
:$put =string(d)
:"
:" manipulating a big Dictionary
:let d = {}
:for i in range(15000)
: let d[i] = 30000 - i
:endfor
:$put =d[0] . ' ' . d[100] . ' ' . d[999] . ' ' . d[14000] . ' ' . d[14999]
:try
:  let n = d[15000]
:catch
:  $put =v:exception[:14] . v:exception[-5:-1]
:endtry
:" lookup each items
:for i in range(15000)
: if d[i] != 30000 - i
:  $put =d[i]
: endif
:endfor
: let i += 1
:" delete even items
:while i >= 2
: let i -= 2
: unlet d[i]
:endwhile
:$put =get(d, 15000 - 100, 'NONE') . ' ' . d[1]
:" delete odd items, checking value, one intentionally wrong
:let d[33] = 999
:let i = 1
:while i < 15000
: if d[i] != 30000 - i
:  $put =i . '=' . d[i]
: else
:  unlet d[i]
: endif
: let i += 2
:endwhile
:$put =string(d)  " must be almost empty now
:unlet d
:"
:" Dictionary function
:let dict = {}
:func dict.func(a) dict
:  $put =a:a . len(self.data)
:endfunc
:let dict.data = [1,2,3]
:call dict.func("len: ")
:echo dict.func("again: ")
:try
:  let Fn = dict.func
:  call Fn('xxx')
:catch
:  $put =v:exception[:15]
:endtry
:sleep 5
:" 
:" Nasty: remove func from Dict that's being called (works)
:let d = {1:1}
:func d.func(a)
:  return "a:". a:a
:endfunc
:$put = d.func(string(remove(d, 'func')))
:"
:" Nasty: deepcopy() dict that refers to itself (fails)
:let d = {1:1, 2:2}
:let l = [4, d, 6]
:let d[3] = l
:try
:  let x = deepcopy(d)
:catch
:  $put =v:exception[:14]
:endtry
:"
:endfun
:call Test()
:"
:/^start:/,$wq! test.out
ENDTEST

start:
